# Инструменты MCP-сервера

Документ описывает доступные инструменты MCP-сервера из `server.py`, формат их запросов и ответов,
а также особенности обработки изображений.

## Переменные окружения

- `ANKI_DEFAULT_DECK` — имя колоды, которое будет использоваться по умолчанию, если клиент не передал параметр `deck`.
- `ANKI_DEFAULT_MODEL` — имя модели, используемой по умолчанию при отсутствии параметра `model`. По умолчанию это пользовательская модель `Поля для ChatGPT` c полями `Prompt`, `Response`, `Context`, `Sources` (в этом порядке).
- `SEARCH_API_URL` — базовый URL внешнего поиска (HTTP endpoint, webhook n8n и т.п.), который будет вызываться действием `search`.
- `SEARCH_API_KEY` — необязательный ключ/токен для авторизации во внешнем поиске. Если не задан, заголовок `Authorization` не добавляется.

Переменные для Anki необязательные: пустое значение приводит к использованию стандартных `"Default"` и `"Поля для ChatGPT"` соответственно.
Переменные поиска также можно оставить пустыми — тогда действие `search` будет недоступно и сервер сообщит об ошибке при попытке вызвать его без настроек.

## Общие структуры данных

### `ImageSpec`
- **Назначение:** описывает изображение, которое нужно добавить к заметке Anki.
- **Поля:**
  - `image_base64: str | None` — необязательный Base64-контент изображения.
  - `image_url: AnyHttpUrl | None` — необязательная ссылка на изображение. Используется, если `image_base64` не передан. Клиенты могут передавать её как `image_url` или упрощённый алиас `url`.
  - `target_field: str` — поле модели, куда следует подставить тег `<img>`; по умолчанию `"Back"`.
  - `filename: str | None` — пользовательское имя медиа-файла. Если не задано, генерируется UUID с расширением `.jpg`.
  - `max_side: int` — максимальный размер длинной стороны при авто-ресайзе (по умолчанию `768`).

#### Единый HTML-формат

Независимо от того, был ли контент передан через `images[]` или как data URL напрямую в `fields`, после сохранения медиа значение поля содержит HTML-обёртку вида:

```
<div><img src="FILENAME" style="max-width:100%;height:auto"/></div>
```

- Если поле уже содержит текст, HTML добавляется через пустую строку, сохраняя исходное содержимое заметки.
- При повторной обработке одного и того же файла тег `<img>` не дублируется.
- В шаблонах Anki достаточно вывести поле (`{{Back}}`, `{{Image}}` и т.п.) — дополнительный `<img>` в шаблонах не требуется.

### `NoteInput`
- **Назначение:** входные данные для создания заметки.
- **Поля:**
  - `fields: Dict[str, str]` — значения полей заметки.
  - `tags: List[str]` — необязательные теги; по умолчанию пустой список.
  - `images: List[ImageSpec]` — список изображений (см. выше); по умолчанию пуст.
  - `dedup_key: str | None` — необязательный ключ для идемпотентности, используется в `anki.add_from_model`.

### `AddNotesArgs`
- **Используется в:** `anki.add_notes`.
- **Поля:**
  - `deck: str` — имя колоды. Если параметр не передан, используется значение из `ANKI_DEFAULT_DECK` (по умолчанию `"Default"`).
  - `model: str` — имя модели. При отсутствии значения используется `ANKI_DEFAULT_MODEL` (по умолчанию `"Поля для ChatGPT"`).
  - `notes: List[NoteInput]` — список заметок (обязательный, минимум один элемент).

### `AddNotesResult`
- **Структура ответа** для инструментов, добавляющих заметки.
- **Поля:**
  - `added: int` — количество успешно созданных заметок.
  - `skipped: int` — количество пропущенных заметок (например, дубликатов).
  - `details: List[dict]` — дополнительные сведения по каждой заметке (индекс, статус, предупреждения и т.п.).

### `ModelInfo`
- **Используется в:** `anki.model_info`.
- **Поля:**
  - `model: str` — имя модели.
  - `fields: List[str]` — список полей модели.
  - `templates: Dict[str, Dict[str, str]]` — шаблоны карточек вида `{ "Card 1": { "Front": "...", "Back": "..." } }`.
  - `styling: str` — CSS-маркировка модели.

### `SearchRequest`
- **Используется в:** `search`.
- **Поля:**
  - `query: str` — поисковый запрос (обязательный, пробелы по краям обрезаются).
  - `limit: int | None` — необязательный лимит результатов на страницу.
  - `cursor: str | None` — маркер постраничной навигации, передаётся как есть во внешний API.

### `SearchResult`
- **Используется в:** `search`.
- **Поля:**
  - `title: str | None` — заголовок результата.
  - `url: AnyHttpUrl | None` — ссылка на исходный материал.
  - `snippet: str | None` — краткое описание/фрагмент.
  - `content: str | None` — расширенное содержимое (если доступно).
  - `score: float | None` — числовая оценка релевантности.
  - Дополнительные поля сохраняются как есть и доступны клиенту.

### `SearchResponse`
- **Используется в:** `search`.
- **Поля:**
  - `results: List[SearchResult]` — список найденных материалов.
  - `nextCursor: str | None` — курсор для следующей страницы (может отсутствовать).

## Инструменты

### `anki.model_info`
- **Назначение:** получить актуальные поля, шаблоны (Front/Back) и CSS выбранной модели Anki.
- **Параметры:**
  - `model: str` — имя модели. Если параметр опущен, используется `ANKI_DEFAULT_MODEL` (`"Поля для ChatGPT"`, если переменная не задана или пуста).
- **Ответ:** объект `ModelInfo` (см. выше).
- **Пример запроса:**
```json
{
  "name": "anki.model_info",
  "arguments": {
    "model": "Поля для ChatGPT"
  }
}
```
- **Пример ответа:**
```json
{
  "model": "Поля для ChatGPT",
  "fields": ["Prompt", "Response", "Context", "Sources"],
  "templates": {
    "Card 1": {
      "Front": "<div class=\"prompt\">{{Prompt}}</div>\n{{#Context}}<div class=\"context\">{{Context}}</div>{{/Context}}\n{{tts de_DE voices=AwesomeTTS:Prompt}}",
      "Back": "{{FrontSide}}\n<hr id=\"answer\">\n<div class=\"response\">{{Response}}</div>\n{{#Sources}}<div class=\"sources\">{{Sources}}</div>{{/Sources}}"
    }
  },
  "styling": ".card {\n  font-family: \"Inter\", \"Segoe UI\", sans-serif;\n  font-size: 22px;\n  text-align: left;\n  line-height: 1.5;\n}\n.prompt {\n  font-weight: 600;\n  font-size: 24px;\n  margin-bottom: 12px;\n}\n.context {\n  color: #4a5568;\n  font-style: italic;\n  margin-bottom: 16px;\n}\n.response {\n  color: #1a202c;\n  font-size: 22px;\n  margin-bottom: 12px;\n}\n.sources {\n  color: #2d3748;\n  font-size: 18px;\n  white-space: pre-wrap;\n}"
}
```


> **Важно.** Клиент должен передавать значения полей строго в порядке `Prompt`, `Response`, `Context`, `Sources`. Шаблон фронта включает вызов `{{tts de_DE voices=AwesomeTTS:Prompt}}`, поэтому в Anki должен быть настроен профиль AwesomeTTS, который озвучивает поле `Prompt`.


### `anki.add_from_model`
- **Назначение:** добавить заметки в указанную колоду с учётом текущих полей и шаблонов модели. Инструмент сам загружает структуру модели, нормализует `fields` и обрабатывает вложенные изображения.
- **Параметры:**
  - `deck: str` — целевая колода. Если параметр опущен, используется `ANKI_DEFAULT_DECK` (`"Default"`, если переменная не задана или пуста).
  - `model: str` — модель карточки. По умолчанию берётся `ANKI_DEFAULT_MODEL` (`"Поля для ChatGPT"`, если переменная не задана или пуста).
  - `items: List[NoteInput | dict]` — список заметок (обязателен). Для каждого элемента можно передавать:
    - полноценный объект `NoteInput` с ключами `fields`/`tags`/`images`/`dedup_key`;
    - или плоский словарь, где верхнеуровневые ключи соответствуют полям модели, а служебные атрибуты (`tags`, `images`, `dedup_key`) указываются рядом.
- **Ответ:** объект `AddNotesResult`.
- **Особенности:**
  - До добавления создаёт колоду при необходимости.
  - Поддерживает `dedup_key` и добавляет его в `details` успешных заметок.
  - Имена полей для изображений (`target_field`) можно передавать в любом регистре; сервер приведёт их к каноническому виду модели и добавит предупреждение `"unknown_target_field"`, если подходящее поле не найдено.
  - Удобен, когда структура модели может отличаться от ожидаемой — инструмент сам приводит данные в соответствие.
- **Пример запроса:**
```json
{
  "name": "anki.add_from_model",
  "arguments": {
    "deck": "Default",
    "model": "Поля для ChatGPT",
    "items": [
      {
        "Prompt": "Расскажи коротко про столицу Франции",
        "Response": "Столица Франции — Париж.",
        "Context": "Основные факты",
        "Sources": "https://ru.wikipedia.org/wiki/Париж",
        "tags": ["geo", "de"],
        "dedup_key": "geo-paris"
      },
      {
        "fields": {
          "Prompt": "Что нужно знать о столице Германии?",
          "Response": "Столица Германии — Берлин.",
          "Context": "Краткая справка",
          "Sources": "https://ru.wikipedia.org/wiki/Берлин"
        },
        "tags": ["geo", "de"]
      }
    ]
  }
}
```
- **Пример ответа:**
```json
{
  "added": 1,
  "skipped": 0,
  "details": [
    {
      "index": 0,
      "status": "ok",
      "noteId": 1700000000000,
      "dedup_key": "geo-paris"
    }
  ]
}
```


> **Напоминание.** Даже если поля передаются объектом `fields`, сервер сопоставляет их с порядком `Prompt → Response → Context → Sources`, чтобы шаблон с TTS `{{tts de_DE voices=AwesomeTTS:Prompt}}` оставался валидным и продолжал озвучивать поле `Prompt` через соответствующий профиль AwesomeTTS.


### `anki.note_info`
- **Назначение:** получить подробные сведения о заметках по их идентификаторам.
- **Параметры:**
  - `noteIds: List[int]` — список идентификаторов заметок (обязателен, минимум один идентификатор).
- **Ответ:** объект с единственным полем `notes`. Значение — список, где каждая позиция соответствует идентификатору из запроса и содержит либо полную структуру заметки (`NoteInfo`), либо `null`, если заметка не найдена или недоступна.
- **Структура `NoteInfo`:**
  - `noteId: int` — идентификатор заметки.
  - `modelName: str | null` — имя модели, если его удалось получить.
  - `deckName: str | null` — имя колоды, где хранится заметка.
  - `tags: List[str]` — список тегов заметки.
  - `fields: Dict[str, str]` — значения полей заметки.
  - `cards: List[int]` — идентификаторы карточек, связанных с заметкой.
- **Пример запроса:**
```json
{
  "name": "anki.note_info",
  "arguments": {
    "noteIds": [1700000000000, 1700000000005]
  }
}
```
- **Пример ответа:**
```json
{
  "notes": [
    {
      "noteId": 1700000000000,
      "modelName": "Поля для ChatGPT",
      "deckName": "Default",
      "tags": ["geo"],
      "fields": {
        "Prompt": "Расскажи коротко про столицу Франции",
        "Response": "Столица Франции — Париж.",
        "Context": "Основные факты",
        "Sources": "https://ru.wikipedia.org/wiki/Париж"
      },
      "cards": [1700000000100]
    },
    null
  ]
}
```

### `anki.add_notes`
- **Назначение:** низкоуровневое добавление заметок без автоматической подстройки под структуру модели. Используется для случаев, когда клиент уже знает точное соответствие полей.
- **Параметры:**
  - `deck: str` — целевая колода. При отсутствии параметра используется `ANKI_DEFAULT_DECK` (`"Default"`).
  - `model: str` — модель карточки. Если аргумент опущен, применяется `ANKI_DEFAULT_MODEL` (`"Поля для ChatGPT"`).
  - `notes: List[NoteInput]` — список заметок (обязателен, минимум один).
- **Ответ:** объект `AddNotesResult`.
- **Особенности:**
  - Не вызывает `get_model_fields_templates`, поэтому переданные `fields` должны соответствовать модели по названиям.
  - При вставке изображений `target_field` обрабатывается без учёта регистра; если поле не найдено в модели, инструмент возбуждает `ValueError`, заметки не отправляются в Anki — в отличие от `anki.add_from_model`, который лишь добавляет предупреждение `"unknown_target_field"`.
  - Чтобы заранее отловить потенциальный `ValueError`, перед вызовом стоит сверить названия полей с моделью (например, запросив их через `anki.model_info` или проверив в интерфейсе Anki).
  - Сохраняет обратную совместимость со старыми клиентами.
- **Пример запроса:**
```json
{
  "name": "anki.add_notes",
  "arguments": {
    "deck": "Default",
    "model": "Поля для ChatGPT",
    "notes": [
      {
        "fields": {
          "Prompt": "Это тестовая карточка",
          "Response": "Ответ добавлен через add_notes.",
          "Context": "Проверка низкоуровневого метода",
          "Sources": ""
        },
        "tags": [],
        "images": []
      }
    ]
  }
}
```
- **Пример ответа:**
```json
{
  "added": 1,
  "skipped": 0,
  "details": [
    {
      "index": 0,
      "status": "ok",
      "noteId": 1700000000001
    }
  ]
}
```

### `search`
- **Назначение:** вызвать внешний поисковый сервис (n8n, собственный API и т.п.) и получить нормализованный список результатов.
- **Параметры:**
  - `query: str` — поисковый запрос (обязателен).
  - `limit: int | None` — максимальное число результатов на страницу (необязательно).
  - `cursor: str | None` — курсор постраничной навигации; передаётся в внешний API как есть.
- **Ответ:** объект `SearchResponse`.
- **Особенности:**
  - Адрес и ключ авторизации берутся из переменных окружения `SEARCH_API_URL` и `SEARCH_API_KEY`.
  - Действие ожидает, что внешний сервис вернёт `results` (или `items`) и опциональный `nextCursor`/`next_cursor`.
- **Пример запроса:**
```json
{
  "name": "search",
  "arguments": {
    "query": "site:n8n.io ChatGPT connector",
    "limit": 5
  }
}
```
- **Пример ответа:**
```json
{
  "results": [
    {
      "title": "n8n ChatGPT automation",
      "url": "https://community.n8n.io/t/chatgpt-connector/12345",
      "snippet": "Готовый workflow для интеграции ChatGPT и n8n.",
      "score": 0.83
    }
  ],
  "nextCursor": "opaque-token"
}
```

### `greet`
- **Назначение:** тестовый пинг для проверки связи с MCP-сервером.
- **Параметры:**
  - `name: str` — имя пользователя (обязательный).
- **Ответ:** строка с приветствием.
- **Пример запроса:**
```json
{
  "name": "greet",
  "arguments": {
    "name": "Алиса"
  }
}
```
- **Пример ответа:**
```json
"Привет, Алиса! Я твой MCP-сервер."
```

## Работа с изображениями и HTML-полями

Обработка изображений выполняется в нескольких функциях.

1. **`process_data_urls_in_fields`** — ищет значения вида `data:image/...;base64,<данные>` во всех строковых полях заметки. Регистрозависимость отсутствует, поэтому подходят варианты вроде `DATA:image/PNG;BASE64,...`. При успешной декодировке:
   - вычисляет SHA-1 хэш бинарных данных для формирования уникального имени файла (`img_<hash>.<ext>`), где расширение выбирается функцией `ext_from_mime`;
   - сохраняет файл через `store_media_file`;
   - заменяет значение поля на имя файла, чтобы шаблон модели мог подставить `<img src="...">` автоматически;
   - записывает диагностическую информацию в `details` результата. При ошибках добавляет предупреждение с причиной.

2. **`fetch_image_as_base64`** — загружает изображение по URL и, если Pillow распознаёт формат, выполняет авто-ресайз: длинная сторона ограничивается `max_side`, изображение пересохраняется в JPEG с качеством `85`. Если обработка не удалась, файл отправляется как есть. Результат возвращается в Base64 для дальнейшей передачи в Anki.

3. **`ensure_img_tag`** — при обработке списка `images[]` добавляет в целевое поле HTML-тег `<img>` внутри обёртки `<div>` и сохраняет предыдущий текст поля. Если в поле уже были данные, новый тег отделяется пустой строкой для читаемости.

### Использование `images[]`

Каждый элемент `images[]` преобразуется следующим образом:
- выбирается имя файла: либо из `filename`, либо автоматически на основе UUID;
- источник данных — `image_base64` (приоритет) или `image_url` с последующей загрузкой через `fetch_image_as_base64` и возможным ресайзом до `max_side` пикселей;
- файл сохраняется через `store_media_file`;
- в поле `target_field` подставляется HTML, возвращённый `ensure_img_tag`, что гарантирует присутствие `<img>` даже если шаблон модели не делает этого автоматически.

### Сравнение сценариев `anki.add_from_model` и `anki.add_notes`

- `anki.add_from_model` предварительно запрашивает структуру модели (`modelFieldNames`, `modelTemplates`, `modelStyling`) и нормализует поля через `normalize_fields_for_model`. Это облегчает интеграцию с динамическими моделями и позволяет использовать `dedup_key` в отчёте.
- `anki.add_notes` не делает дополнительных запросов к Anki и ожидает, что клиент уже согласовал названия полей. Он служит для обратной совместимости с существующими сценариями и может быть быстрее, если структура модели известна заранее.

Оба инструмента используют общие механизмы обработки `data:image/...;base64` и `images[]`, что обеспечивает единое поведение при работе с медиа.
