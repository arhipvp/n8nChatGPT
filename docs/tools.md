# Инструменты MCP-сервера

Документ описывает доступные инструменты MCP-сервера из `server.py`, формат их запросов и ответов,
а также особенности обработки изображений.

## Переменные окружения

- `ANKI_DEFAULT_DECK` — имя колоды, которое будет использоваться по умолчанию, если клиент не передал параметр `deck`.
- `ANKI_DEFAULT_MODEL` — имя модели, используемой по умолчанию при отсутствии параметра `model`. По умолчанию это пользовательская модель `Поля для ChatGPT` c полями `Prompt`, `Response`, `Context`, `Sources` (в этом порядке).
- `SEARCH_API_URL` — базовый URL внешнего поиска (HTTP endpoint, webhook n8n и т.п.), который будет вызываться действием `search`.
- `SEARCH_API_KEY` — необязательный ключ/токен для авторизации во внешнем поиске. Если не задан, заголовок `Authorization` не добавляется.

Переменные для Anki необязательные: пустое значение приводит к использованию стандартных `"Default"` и `"Поля для ChatGPT"` соответственно.
Переменные поиска также можно оставить пустыми — тогда действие `search` будет недоступно и сервер сообщит об ошибке при попытке вызвать его без настроек.

## Общие структуры данных

### `ImageSpec`
- **Назначение:** описывает изображение, которое нужно добавить к заметке Anki.
- **Поля:**
  - `image_base64: str | None` — необязательный Base64-контент изображения.
  - `image_url: AnyHttpUrl | None` — необязательная ссылка на изображение. Используется, если `image_base64` не передан. Клиенты могут передавать её как `image_url` или упрощённый алиас `url`.
  - `target_field: str` — поле модели, куда следует подставить тег `<img>`; по умолчанию `"Back"`.
  - `filename: str | None` — пользовательское имя медиа-файла. Если не задано, генерируется UUID с расширением `.jpg`.
  - `max_side: int` — максимальный размер длинной стороны при авто-ресайзе (по умолчанию `768`).

#### Единый HTML-формат

Независимо от того, был ли контент передан через `images[]` или как data URL напрямую в `fields`, после сохранения медиа значение поля содержит HTML-обёртку вида:

```
<div><img src="FILENAME" style="max-width:100%;height:auto"/></div>
```

- Если поле уже содержит текст, HTML добавляется через пустую строку, сохраняя исходное содержимое заметки.
- При повторной обработке одного и того же файла тег `<img>` не дублируется.
- В шаблонах Anki достаточно вывести поле (`{{Back}}`, `{{Image}}` и т.п.) — дополнительный `<img>` в шаблонах не требуется.

### `MediaRequest`
- **Назначение:** описывает файл в медиахранилище Anki.
- **Поля:**
  - `filename: str` — точное имя файла (с учётом регистра и расширения), как оно хранится в каталоге `collection.media`.

### `MediaResponse`
- **Используется в:** `anki.get_media`.
- **Поля:**
  - `filename: str` — имя файла, для которого запрошен контент.
  - `dataBase64: str` — содержимое файла в кодировке Base64 (сервер не декодирует его автоматически).
  - `sizeBytes: int | None` — размер бинарного содержимого после декодирования Base64. Может отсутствовать (`null`), если AnkiConnect вернул повреждённую строку.

### `DeleteMediaArgs`
- **Используется в:** `anki.delete_media`.
- **Поля:**
  - `filename: str` — имя файла в медиахранилище Anki, который требуется удалить.

### `NoteInput`
- **Назначение:** входные данные для создания заметки.
- **Поля:**
  - `fields: Dict[str, str]` — значения полей заметки.
  - `tags: List[str]` — необязательные теги; по умолчанию пустой список.
  - `images: List[ImageSpec]` — список изображений (см. выше); по умолчанию пуст.
  - `dedup_key: str | None` — необязательный ключ для идемпотентности, используется в `anki.add_from_model`.

### `AddNotesArgs`
- **Используется в:** `anki.add_notes`.
- **Поля:**
  - `deck: str` — имя колоды. Если параметр не передан, используется значение из `ANKI_DEFAULT_DECK` (по умолчанию `"Default"`).
  - `model: str` — имя модели. При отсутствии значения используется `ANKI_DEFAULT_MODEL` (по умолчанию `"Поля для ChatGPT"`).
  - `notes: List[NoteInput]` — список заметок (обязательный, минимум один элемент).

### `AddNotesResult`
- **Структура ответа** для инструментов, добавляющих заметки.
- **Поля:**
  - `added: int` — количество успешно созданных заметок.
  - `skipped: int` — количество пропущенных заметок (например, дубликатов).
  - `details: List[dict]` — дополнительные сведения по каждой заметке (индекс, статус, предупреждения и т.п.).

### `DeleteNotesArgs`
- **Используется в:** `anki.delete_notes`.
- **Поля:**
  - `noteIds: List[int]` — список идентификаторов заметок для удаления (обязателен, минимум один элемент).

### `DeleteNotesResult`
- **Используется в:** `anki.delete_notes`.
- **Поля:**
  - `deleted: int` — количество успешно удалённых заметок.
  - `missing: int` — количество заметок, которые не удалось удалить (например, они уже отсутствуют в базе Anki).

### `NoteUpdate`
- **Назначение:** описывает изменения для существующей заметки.
- **Поля:**
  - `noteId: int` — идентификатор заметки в Anki.
  - `fields: Dict[str, str] | None` — частичный набор полей, которые нужно изменить.
  - `addTags: List[str]` — теги, которые следует добавить к заметке.
  - `removeTags: List[str]` — теги, которые нужно удалить.
  - `deckName: str | None` — новая колода; если не указана или совпадает с текущей, перенос не выполняется.
  - `images: List[ImageSpec]` — вложения-изображения; можно указывать также ключ `attachments`.

### `UpdateNotesArgs`
- **Используется в:** `anki.update_notes`.
- **Поля:**
  - `notes: List[NoteUpdate]` — список изменений (обязателен, минимум один элемент).

### `UpdateNotesResult`
- **Используется в:** `anki.update_notes`.
- **Поля:**
  - `updated: int` — количество успешно обновлённых заметок.
  - `skipped: int` — количество заметок, которые не удалось обновить (ошибка, отсутствующая заметка и т.п.).
  - `details: List[dict]` — подробности по каждой заметке (статус, обновлённые поля, предупреждения, сообщения).

### `FindNotesArgs`
- **Используется в:** `anki.find_notes`.
- **Поля:**
  - `query: str` — поисковый запрос Anki (обязателен, пробелы по краям обрезаются).
  - `limit: int | None` — необязательный лимит возвращаемых идентификаторов. Если не задан, Anki вернёт все совпадения, а сервер
    передаст их целиком.
  - `offset: int` — смещение, с которого следует начинать список идентификаторов. Полезно для постраничного обхода результатов.

### `FindNotesResponse`
- **Используется в:** `anki.find_notes`.
- **Поля:**
  - `noteIds: List[int]` — отсортированный список идентификаторов заметок после применения `offset`/`limit` (если переданы).
  - `notes: List[NoteInfo | None]` — краткое превью найденных заметок, полученное через `notesInfo`. Каждая позиция соответствует
    идентификатору из `noteIds`; если Anki вернул `null`, позиция в списке тоже будет `null`.

### `ModelInfo`
- **Используется в:** `anki.model_info`.
- **Поля:**
  - `model: str` — имя модели.
  - `fields: List[str]` — список полей модели.
  - `templates: Dict[str, Dict[str, str]]` — шаблоны карточек вида `{ "Card 1": { "Front": "...", "Back": "..." } }`.
  - `styling: str` — CSS-маркировка модели.

### `CardTemplateSpec`
- **Назначение:** описывает шаблон карточки новой модели.
- **Поля:**
  - `name: str` — название карточки (например, `"Card 1"`).
  - `front: str` — HTML-шаблон лицевой стороны.
  - `back: str` — HTML-шаблон оборотной стороны.

### `CreateModelArgs`
- **Используется в:** `anki.create_model`.
- **Поля:**
  - `model_name: str` — название новой модели.
  - `in_order_fields: List[str]` — имена полей в нужном порядке (минимум одно значение).
  - `card_templates: List[CardTemplateSpec]` — набор карточек (минимум одна запись).
  - `css: str` — CSS-оформление модели (опционально, по умолчанию пустая строка).
  - `is_cloze: bool | None` — флаг создания модели типа Cloze.
  - `options: Dict[str, Any]` — дополнительные параметры AnkiConnect (например, `latexPre`/`latexPost`).

### `CreateModelResult`
- **Используется в:** `anki.create_model`.
- **Поля:**
  - `model_name: str` — итоговое имя модели.
  - `in_order_fields: List[str]` — список полей, переданный в AnkiConnect.
  - `card_templates: List[CardTemplateSpec]` — шаблоны карточек, использованные при создании модели.
  - `css: str` — итоговый CSS.
  - `options: Dict[str, Any]` — фактически переданные дополнительные параметры.
  - `anki_response: Any` — ответ AnkiConnect (обычно `null`, если ошибок не возникло).

### `InvokeActionArgs`
- **Используется в:** `anki.invoke`.
- **Поля:**
  - `action: str` — имя метода AnkiConnect (обязательно, пробелы по краям удаляются).
  - `params: Dict[str, Any] | None` — произвольные параметры запроса. Если не переданы, сервер отправит пустой объект.
  - `version: int | None` — версия API AnkiConnect. По умолчанию `6`, но можно указать актуальное значение сервера (например, `7`).

### `SearchRequest`
- **Используется в:** `search`.
- **Поля:**
  - `query: str` — поисковый запрос (обязательный, пробелы по краям обрезаются).
  - `limit: int | None` — необязательный лимит результатов на страницу.
  - `cursor: str | None` — маркер постраничной навигации, передаётся как есть во внешний API.

### `SearchResult`
- **Используется в:** `search`.
- **Поля:**
  - `title: str | None` — заголовок результата.
  - `url: AnyHttpUrl | None` — ссылка на исходный материал.
  - `snippet: str | None` — краткое описание/фрагмент.
  - `content: str | None` — расширенное содержимое (если доступно).
  - `score: float | None` — числовая оценка релевантности.
  - Дополнительные поля сохраняются как есть и доступны клиенту.

### `SearchResponse`
- **Используется в:** `search`.
- **Поля:**
  - `results: List[SearchResult]` — список найденных материалов.
  - `nextCursor: str | None` — курсор для следующей страницы (может отсутствовать).

## Инструменты

### `anki.invoke`
- **Назначение:** вызвать любой метод AnkiConnect, даже если для него нет специализированного инструмента.
- **Параметры:** объект `InvokeActionArgs` (см. выше).
- **Особенности:**
  - Поле `action` обязательно и должно совпадать с именем RPC-метода AnkiConnect (`deckNames`, `addNote`, `multi` и т.д.).
  - `params` может быть опущен — тогда сервер отправит пустой словарь (`{}`), что соответствует большинству методов без аргументов.
  - Параметр `version` по умолчанию равен `6`. Укажите его вручную, если используете нестандартную версию AnkiConnect.
  - Ответ инструмента совпадает с полем `result` AnkiConnect без дополнительной постобработки.
- **Пример запроса (получение списка колод):**
```json
{
  "name": "anki.invoke",
  "arguments": {
    "action": "deckNames"
  }
}
```
- **Пример запроса (`multi` с двумя действиями):**
```json
{
  "name": "anki.invoke",
  "arguments": {
    "action": "multi",
    "params": {
      "actions": [
        {"action": "deckNames", "params": {}},
        {"action": "modelNames", "params": {}}
      ]
    }
  }
}
```
- **Рекомендации:**
  - Для операций, требующих сложных параметров (`findCards`, `updateNoteFields`, `sync`), формируйте структуру `params` в точности как в документации AnkiConnect — сервер не вносит изменений.
  - В пакетных вызовах `multi` полезно указывать `version`, чтобы гарантировать совместимость с текущей версией API.
  - Ошибки AnkiConnect возвращаются в виде исключений `RuntimeError`; обрабатывайте их на стороне клиента, если нужно предоставить пользователю дружелюбное сообщение.

### `anki.list_decks`
- **Назначение:** получить список доступных колод вместе с их идентификаторами.
- **Параметры:** не требуются.
- **Ответ:** список объектов `DeckInfo` (`id: int`, `name: str`). Если Anki возвращает пустой словарь, инструмент вернёт пустой список.
- **Пример запроса:**
```json
{
  "name": "anki.list_decks"
}
```
- **Пример ответа:**
```json
[
  {"id": 1, "name": "Default"},
  {"id": 1700000000000, "name": "Custom::Deck"}
]
```

### `anki.rename_deck`
- **Назначение:** переименовать существующую колоду.
- **Параметры:** объект `RenameDeckArgs` с полями `oldName` и `newName` (оба обязательные).
- **Ответ:** «сырой» результат AnkiConnect (`null` при успехе).
- **Пример запроса:**
```json
{
  "name": "anki.rename_deck",
  "arguments": {
    "oldName": "Default",
    "newName": "Inbox"
  }
}
```

### `anki.delete_decks`
- **Назначение:** удалить одну или несколько колод.
- **Параметры:** объект `DeleteDecksArgs`.
  - `decks: List[str]` — имена колод (минимум одно значение).
  - `cardsToo: bool` — флаг удаления карточек вместе с колодой. По умолчанию `false`, то есть при удалении обычной колоды Anki сначала перемещает карточки в «Default». Установите `true`, если хотите безвозвратно удалить карточки.
- **Ответ:** «сырой» результат AnkiConnect (`null`, если операция прошла успешно).
- **Пример запроса:**
```json
{
  "name": "anki.delete_decks",
  "arguments": {
    "decks": ["Inbox", "Archive::Temp"],
    "cardsToo": true
  }
}
```

### `anki.model_info`
- **Назначение:** получить актуальные поля, шаблоны (Front/Back) и CSS выбранной модели Anki.
- **Параметры:**
  - `model: str` — имя модели. Если параметр опущен, используется `ANKI_DEFAULT_MODEL` (`"Поля для ChatGPT"`, если переменная не задана или пуста).
- **Ответ:** объект `ModelInfo` (см. выше).
- **Пример запроса:**
```json
{
  "name": "anki.model_info",
  "arguments": {
    "model": "Поля для ChatGPT"
  }
}
```
- **Пример ответа:**
```json
{
  "model": "Поля для ChatGPT",
  "fields": ["Prompt", "Response", "Context", "Sources"],
  "templates": {
    "Card 1": {
      "Front": "<div class=\"prompt\">{{Prompt}}</div>\n{{#Context}}<div class=\"context\">{{Context}}</div>{{/Context}}\n{{tts de_DE voices=AwesomeTTS:Prompt}}",
      "Back": "{{FrontSide}}\n<hr id=\"answer\">\n<div class=\"response\">{{Response}}</div>\n{{#Sources}}<div class=\"sources\">{{Sources}}</div>{{/Sources}}"
    }
  },
  "styling": ".card {\n  font-family: \"Inter\", \"Segoe UI\", sans-serif;\n  font-size: 22px;\n  text-align: left;\n  line-height: 1.5;\n}\n.prompt {\n  font-weight: 600;\n  font-size: 24px;\n  margin-bottom: 12px;\n}\n.context {\n  color: #4a5568;\n  font-style: italic;\n  margin-bottom: 16px;\n}\n.response {\n  color: #1a202c;\n  font-size: 22px;\n  margin-bottom: 12px;\n}\n.sources {\n  color: #2d3748;\n  font-size: 18px;\n  white-space: pre-wrap;\n}"
}
```


> **Важно.** Клиент должен передавать значения полей строго в порядке `Prompt`, `Response`, `Context`, `Sources`. Шаблон фронта включает вызов `{{tts de_DE voices=AwesomeTTS:Prompt}}`, поэтому в Anki должен быть настроен профиль AwesomeTTS, который озвучивает поле `Prompt`.


### `anki.create_model`
- **Назначение:** создать новую модель в Anki с заданными полями, шаблонами карточек и CSS.
- **Параметры:** объект `CreateModelArgs` (см. выше). Значения можно указывать как в snake_case (`model_name`), так и в стиле AnkiConnect (`modelName`, `inOrderFields`, `cardTemplates`). Ключ `options` позволяет передать дополнительные параметры, поддерживаемые AnkiConnect (например, `latexPre`).
- **Ответ:** объект `CreateModelResult`. Поле `anki_response` содержит «сырой» результат AnkiConnect (`null`, если модель создана успешно).
- **Пример запроса:**
```json
{
  "name": "anki.create_model",
  "arguments": {
    "modelName": "Custom QA",
    "inOrderFields": ["Question", "Answer", "Context"],
    "cardTemplates": [
      {
        "name": "Card 1",
        "front": "<div class=\"question\">{{Question}}</div>",
        "back": "{{FrontSide}}\n<hr id=\"answer\">\n<div class=\"answer\">{{Answer}}</div>{{#Context}}\n<div class=\"context\">{{Context}}</div>{{/Context}}"
      }
    ],
    "css": ".card {\n  font-family: 'Inter', sans-serif;\n  font-size: 22px;\n}\n.question {\n  font-weight: 600;\n}\n.answer {\n  color: #1a202c;\n}\n.context {\n  color: #4a5568;\n  font-style: italic;\n}",
    "isCloze": false,
    "options": {
      "latexPre": "\\documentclass{article}"
    }
  }
}
```
- **Пример ответа:**
```json
{
  "model_name": "Custom QA",
  "in_order_fields": ["Question", "Answer", "Context"],
  "card_templates": [
    {
      "name": "Card 1",
      "front": "<div class=\"question\">{{Question}}</div>",
      "back": "{{FrontSide}}\n<hr id=\"answer\">\n<div class=\"answer\">{{Answer}}</div>{{#Context}}\n<div class=\"context\">{{Context}}</div>{{/Context}}"
    }
  ],
  "css": ".card {\n  font-family: 'Inter', sans-serif;\n  font-size: 22px;\n}\n.question {\n  font-weight: 600;\n}\n.answer {\n  color: #1a202c;\n}\n.context {\n  color: #4a5568;\n  font-style: italic;\n}",
  "options": {
    "latexPre": "\\documentclass{article}",
    "isCloze": false
  },
  "anki_response": null
}
```

### `anki.add_from_model`
- **Назначение:** добавить заметки в указанную колоду с учётом текущих полей и шаблонов модели. Инструмент сам загружает структуру модели, нормализует `fields` и обрабатывает вложенные изображения.
- **Параметры:**
  - `deck: str` — целевая колода. Если параметр опущен, используется `ANKI_DEFAULT_DECK` (`"Default"`, если переменная не задана или пуста).
  - `model: str` — модель карточки. По умолчанию берётся `ANKI_DEFAULT_MODEL` (`"Поля для ChatGPT"`, если переменная не задана или пуста).
  - `items: List[NoteInput | dict]` — список заметок (обязателен). Для каждого элемента можно передавать:
    - полноценный объект `NoteInput` с ключами `fields`/`tags`/`images`/`dedup_key`;
    - или плоский словарь, где верхнеуровневые ключи соответствуют полям модели, а служебные атрибуты (`tags`, `images`, `dedup_key`) указываются рядом.
- **Ответ:** объект `AddNotesResult`.
- **Особенности:**
  - До добавления создаёт колоду при необходимости.
  - Поддерживает `dedup_key` и добавляет его в `details` успешных заметок.
  - Имена полей для изображений (`target_field`) можно передавать в любом регистре; сервер приведёт их к каноническому виду модели и добавит предупреждение `"unknown_target_field"`, если подходящее поле не найдено.
  - Удобен, когда структура модели может отличаться от ожидаемой — инструмент сам приводит данные в соответствие.
- **Пример запроса:**
```json
{
  "name": "anki.add_from_model",
  "arguments": {
    "deck": "Default",
    "model": "Поля для ChatGPT",
    "items": [
      {
        "Prompt": "Расскажи коротко про столицу Франции",
        "Response": "Столица Франции — Париж.",
        "Context": "Основные факты",
        "Sources": "https://ru.wikipedia.org/wiki/Париж",
        "tags": ["geo", "de"],
        "dedup_key": "geo-paris"
      },
      {
        "fields": {
          "Prompt": "Что нужно знать о столице Германии?",
          "Response": "Столица Германии — Берлин.",
          "Context": "Краткая справка",
          "Sources": "https://ru.wikipedia.org/wiki/Берлин"
        },
        "tags": ["geo", "de"]
      }
    ]
  }
}
```
- **Пример ответа:**
```json
{
  "added": 1,
  "skipped": 0,
  "details": [
    {
      "index": 0,
      "status": "ok",
      "noteId": 1700000000000,
      "dedup_key": "geo-paris"
    }
  ]
}
```


> **Напоминание.** Даже если поля передаются объектом `fields`, сервер сопоставляет их с порядком `Prompt → Response → Context → Sources`, чтобы шаблон с TTS `{{tts de_DE voices=AwesomeTTS:Prompt}}` оставался валидным и продолжал озвучивать поле `Prompt` через соответствующий профиль AwesomeTTS.


### `anki.update_notes`
- **Назначение:** обновить существующие заметки Anki — изменить поля, добавить/удалить теги, перенести карточки в другую колоду и прикрепить новые изображения.
- **Параметры:** объект `UpdateNotesArgs`.
- **Ответ:** объект `UpdateNotesResult`.
- **Особенности:**
  - Инструмент предварительно запрашивает `notesInfo`, чтобы узнать модель, текущую колоду и заполненные поля заметки.
  - Перед обновлением поля нормализуются в соответствии с моделью (`normalize_fields_for_model`), поддерживается обработка data URL и списка `images` (алиас `attachments`).
  - Добавление и удаление тегов выполняется через `addTags`/`removeTags`, перенос в новую колоду — через `changeDeck`.
- **Пример запроса:**
```json
{
  "name": "anki.update_notes",
  "arguments": {
    "notes": [
      {
        "noteId": 1700000000000,
        "fields": {"Front": "Новый вопрос"},
        "addTags": ["updated"],
        "removeTags": ["obsolete"],
        "deckName": "Updated::Deck",
        "images": [
          {
            "image_base64": "data:image/png;base64,iVBORw0...",
            "target_field": "Back"
          }
        ]
      }
    ]
  }
}
```
- **Пример ответа:**
```json
{
  "updated": 1,
  "skipped": 0,
  "details": [
    {
      "index": 0,
      "noteId": 1700000000000,
      "status": "ok",
      "updatedFields": ["Front", "Back"],
      "addedTags": ["updated"],
      "removedTags": ["obsolete"],
      "deckChangedTo": "Updated::Deck"
    }
  ]
}
```


### `anki.delete_notes`
- **Назначение:** удалить существующие заметки Anki и получить агрегированную статистику по успешным и пропущенным идентификаторам.
- **Параметры:** объект `DeleteNotesArgs`.
- **Ответ:** объект `DeleteNotesResult`.
- **Особенности:**
  - Инструмент передаёт список идентификаторов в метод AnkiConnect `deleteNotes` и нормализует самые распространённые форматы ответа (`null`, массив булевых значений, словарь с полями `deleted`/`missing`).
  - Если часть заметок не найдена, счётчик `missing` покажет их количество, даже если AnkiConnect вернул неоднозначный ответ.
  - При пустом списке `noteIds` сработает валидация аргументов, и клиент получит `ValidationError` вида `List should have at least 1 item after validation, not 0`.
- **Пример запроса:**
```json
{
  "name": "anki.delete_notes",
  "arguments": {
    "noteIds": [1700000000000, 1700000000001]
  }
}
```
- **Пример ответа:**
```json
{
  "deleted": 1,
  "missing": 1
}
```

### `anki.delete_media`
- **Назначение:** удалить медиафайл из каталога `collection.media`.
- **Параметры:** объект `DeleteMediaArgs`.
- **Ответ:** словарь вида `{ "filename": str, "deleted": bool, "anki_response": Any }`.
- **Особенности:**
  - Значение `deleted` вычисляется эвристически на основе ответа AnkiConnect (`null`, булевы значения в массиве или словарь `{"deleted": N}`) и отражает, удалось ли удалить файл.
  - Поле `anki_response` содержит необработанный ответ AnkiConnect и помогает отлаживать взаимодействие.
  - При отсутствии файла инструмент выбрасывает `FileNotFoundError`.
- **Пример запроса:**
```json
{
  "name": "anki.delete_media",
  "arguments": {
    "filename": "audio/hello.mp3"
  }
}
```
- **Пример ответа:**
```json
{
  "filename": "audio/hello.mp3",
  "deleted": true,
  "anki_response": null
}
```


### `anki.note_info`
- **Назначение:** получить подробные сведения о заметках по их идентификаторам.
- **Параметры:**
  - `noteIds: List[int]` — список идентификаторов заметок (обязателен, минимум один идентификатор).
- **Ответ:** объект с единственным полем `notes`. Значение — список, где каждая позиция соответствует идентификатору из запроса и содержит либо полную структуру заметки (`NoteInfo`), либо `null`, если заметка не найдена или недоступна.
- **Структура `NoteInfo`:**
  - `noteId: int` — идентификатор заметки.
  - `modelName: str | null` — имя модели, если его удалось получить.
  - `deckName: str | null` — имя колоды, где хранится заметка.
  - `tags: List[str]` — список тегов заметки.
  - `fields: Dict[str, str]` — значения полей заметки.

### `anki.get_media`
- **Назначение:** получить содержимое медиафайла из профиля Anki.
- **Параметры:** объект `MediaRequest`.
- **Ответ:** объект `MediaResponse`.
- **Особенности:**
  - AnkiConnect ограничивает размер возвращаемого файла значением `maxSize` (по умолчанию около 25 МБ).
  - Поле `dataBase64` передаётся как есть — сервер не декодирует его и не меняет формат данных.
  - Поле `sizeBytes` заполняется наилучшим образом: если AnkiConnect вернул некорректную Base64-строку, значение будет `null`.
  - При отсутствии файла инструмент выбрасывает `FileNotFoundError` (обёртка над ошибкой AnkiConnect).
- **Пример запроса:**
```json
{
  "name": "anki.get_media",
  "arguments": {
    "filename": "audio/hello.mp3"
  }
}
```
- **Пример ответа:**
```json
{
  "filename": "audio/hello.mp3",
  "dataBase64": "SUQzBAAAAAAAI1RTU0UAAAAPAAA...",
  "sizeBytes": 12345
}
```

### `anki.find_notes`
- **Назначение:** найти заметки в Anki по поисковому запросу и сразу получить их идентификаторы вместе с краткой информацией.
- **Параметры:**
  - `query: str` — строка запроса (поддерживаются все фильтры Anki: `deck:`, `tag:`, `card:`, `added:`, и т.д.).
  - `limit: int | None` — сколько идентификаторов вернуть после применения смещения. Значение должно быть ≥ 1.
  - `offset: int` — смещение от начала списка результатов (по умолчанию `0`).
- **Ответ:** объект `FindNotesResponse`. Поле `noteIds` содержит итоговый список идентификаторов, а `notes` — выравненный массив
  с результатами `notesInfo` (можно использовать как превью перед загрузкой полного `anki.note_info`).
- **Пример запроса:**
```json
{
  "name": "anki.find_notes",
  "arguments": {
    "query": "deck:Default tag:geo",
    "limit": 10,
    "offset": 20
  }
}
```
- **Пример ответа:**
```json
{
  "noteIds": [1700000000000, 1700000000001],
  "notes": [
    {
      "noteId": 1700000000000,
      "modelName": "Basic",
      "deckName": "Default",
      "tags": ["geo", "review"],
      "fields": {
        "Front": "Столица Франции?",
        "Back": "Париж"
      },
      "cards": [1700000000002, 1700000000003]
    },
    null
  ]
}
```
  - `cards: List[int]` — идентификаторы карточек, связанных с заметкой.
- **Пример запроса:**
```json
{
  "name": "anki.note_info",
  "arguments": {
    "noteIds": [1700000000000, 1700000000005]
  }
}
```
- **Пример ответа:**
```json
{
  "notes": [
    {
      "noteId": 1700000000000,
      "modelName": "Поля для ChatGPT",
      "deckName": "Default",
      "tags": ["geo"],
      "fields": {
        "Prompt": "Расскажи коротко про столицу Франции",
        "Response": "Столица Франции — Париж.",
        "Context": "Основные факты",
        "Sources": "https://ru.wikipedia.org/wiki/Париж"
      },
      "cards": [1700000000100]
    },
    null
  ]
}
```

### `anki.add_notes`
- **Назначение:** низкоуровневое добавление заметок без автоматической подстройки под структуру модели. Используется для случаев, когда клиент уже знает точное соответствие полей.
- **Параметры:**
  - `deck: str` — целевая колода. При отсутствии параметра используется `ANKI_DEFAULT_DECK` (`"Default"`).
  - `model: str` — модель карточки. Если аргумент опущен, применяется `ANKI_DEFAULT_MODEL` (`"Поля для ChatGPT"`).
  - `notes: List[NoteInput]` — список заметок (обязателен, минимум один).
- **Ответ:** объект `AddNotesResult`.
- **Особенности:**
  - Не вызывает `get_model_fields_templates`, поэтому переданные `fields` должны соответствовать модели по названиям.
  - При вставке изображений `target_field` обрабатывается без учёта регистра; если поле не найдено в модели, инструмент возбуждает `ValueError`, заметки не отправляются в Anki — в отличие от `anki.add_from_model`, который лишь добавляет предупреждение `"unknown_target_field"`.
  - Чтобы заранее отловить потенциальный `ValueError`, перед вызовом стоит сверить названия полей с моделью (например, запросив их через `anki.model_info` или проверив в интерфейсе Anki).
  - Сохраняет обратную совместимость со старыми клиентами.
- **Пример запроса:**
```json
{
  "name": "anki.add_notes",
  "arguments": {
    "deck": "Default",
    "model": "Поля для ChatGPT",
    "notes": [
      {
        "fields": {
          "Prompt": "Это тестовая карточка",
          "Response": "Ответ добавлен через add_notes.",
          "Context": "Проверка низкоуровневого метода",
          "Sources": ""
        },
        "tags": [],
        "images": []
      }
    ]
  }
}
```
- **Пример ответа:**
```json
{
  "added": 1,
  "skipped": 0,
  "details": [
    {
      "index": 0,
      "status": "ok",
      "noteId": 1700000000001
    }
  ]
}
```

### `search`
- **Назначение:** вызвать внешний поисковый сервис (n8n, собственный API и т.п.) и получить нормализованный список результатов.
- **Параметры:**
  - `query: str` — поисковый запрос (обязателен).
  - `limit: int | None` — максимальное число результатов на страницу (необязательно).
  - `cursor: str | None` — курсор постраничной навигации; передаётся в внешний API как есть.
- **Ответ:** объект `SearchResponse`.
- **Особенности:**
  - Адрес и ключ авторизации берутся из переменных окружения `SEARCH_API_URL` и `SEARCH_API_KEY`.
  - Действие ожидает, что внешний сервис вернёт `results` (или `items`) и опциональный `nextCursor`/`next_cursor`.
- **Пример запроса:**
```json
{
  "name": "search",
  "arguments": {
    "query": "site:n8n.io ChatGPT connector",
    "limit": 5
  }
}
```
- **Пример ответа:**
```json
{
  "results": [
    {
      "title": "n8n ChatGPT automation",
      "url": "https://community.n8n.io/t/chatgpt-connector/12345",
      "snippet": "Готовый workflow для интеграции ChatGPT и n8n.",
      "score": 0.83
    }
  ],
  "nextCursor": "opaque-token"
}
```

### `greet`
- **Назначение:** тестовый пинг для проверки связи с MCP-сервером.
- **Параметры:**
  - `name: str` — имя пользователя (обязательный).
- **Ответ:** строка с приветствием.
- **Пример запроса:**
```json
{
  "name": "greet",
  "arguments": {
    "name": "Алиса"
  }
}
```
- **Пример ответа:**
```json
"Привет, Алиса! Я твой MCP-сервер."
```

## Работа с изображениями и HTML-полями

Обработка изображений выполняется в нескольких функциях.

1. **`process_data_urls_in_fields`** — ищет значения вида `data:image/...;base64,<данные>` во всех строковых полях заметки. Регистрозависимость отсутствует, поэтому подходят варианты вроде `DATA:image/PNG;BASE64,...`. При успешной декодировке:
   - вычисляет SHA-1 хэш бинарных данных для формирования уникального имени файла (`img_<hash>.<ext>`), где расширение выбирается функцией `ext_from_mime`;
   - сохраняет файл через `store_media_file`;
   - заменяет значение поля на имя файла, чтобы шаблон модели мог подставить `<img src="...">` автоматически;
   - записывает диагностическую информацию в `details` результата. При ошибках добавляет предупреждение с причиной.

2. **`fetch_image_as_base64`** — загружает изображение по URL и, если Pillow распознаёт формат, выполняет авто-ресайз: длинная сторона ограничивается `max_side`, изображение пересохраняется в JPEG с качеством `85`. Если обработка не удалась, файл отправляется как есть. Результат возвращается в Base64 для дальнейшей передачи в Anki.

3. **`ensure_img_tag`** — при обработке списка `images[]` добавляет в целевое поле HTML-тег `<img>` внутри обёртки `<div>` и сохраняет предыдущий текст поля. Если в поле уже были данные, новый тег отделяется пустой строкой для читаемости.

### Использование `images[]`

Каждый элемент `images[]` преобразуется следующим образом:
- выбирается имя файла: либо из `filename`, либо автоматически на основе UUID;
- источник данных — `image_base64` (приоритет) или `image_url` с последующей загрузкой через `fetch_image_as_base64` и возможным ресайзом до `max_side` пикселей;
- файл сохраняется через `store_media_file`;
- в поле `target_field` подставляется HTML, возвращённый `ensure_img_tag`, что гарантирует присутствие `<img>` даже если шаблон модели не делает этого автоматически.

### Сравнение сценариев `anki.add_from_model` и `anki.add_notes`

- `anki.add_from_model` предварительно запрашивает структуру модели (`modelFieldNames`, `modelTemplates`, `modelStyling`) и нормализует поля через `normalize_fields_for_model`. Это облегчает интеграцию с динамическими моделями и позволяет использовать `dedup_key` в отчёте.
- `anki.add_notes` не делает дополнительных запросов к Anki и ожидает, что клиент уже согласовал названия полей. Он служит для обратной совместимости с существующими сценариями и может быть быстрее, если структура модели известна заранее.

Оба инструмента используют общие механизмы обработки `data:image/...;base64` и `images[]`, что обеспечивает единое поведение при работе с медиа.
