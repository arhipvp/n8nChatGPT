# n8n ChatGPT MCP Bridge

## Назначение
Проект запускает локальный MCP-сервер на базе [`fastmcp`](https://github.com/entrez/fastmcp) и пробрасывает его наружу через `ngrok`, чтобы подключить кастомный коннектор в ChatGPT. Основная логика описана в [`main.py`](main.py).

## Зависимости
Для работы требуется Python 3.10+ и следующие пакеты (см. запуск MCP-сервера в `main.py`):
- `fastmcp` — каркас MCP-сервера и транспорт.
- `fastapi` — HTTP-приложение, которое разворачивает сервер.
- `httpx` — клиент для запросов к внешним API.
- `Pillow` — обработка изображений при загрузке медиа.
- `requests` — простые синхронные HTTP-запросы.
- `python-dotenv` — загрузка переменных окружения из `.env`.
- `pydantic` — декларативные модели и валидация данных.
- Anki с установленным плагином [AnkiConnect](https://foosoft.net/projects/anki-connect/) и запущенным Anki-клиентом

## Требования к ngrok
Скрипт ищет исполняемый файл ngrok рядом с собой (`main.py` определяет абсолютный путь к каталогу проекта), затем в `PATH` и типичных папках Windows, после чего поднимает HTTP-туннель и извлекает публичный URL через локальный API `http://127.0.0.1:4040`. Эти шаги реализованы в функциях `find_ngrok_exe`, `ngrok_api_alive` и `get_ngrok_url` в `main.py`. Убедитесь, что:
- ngrok установлен; авторизация произойдёт автоматически, если задать `NGROK_AUTHTOKEN` в `.env` или окружении (файл `.env` подхватывается относительно директории скрипта, поэтому запуск из любого рабочего каталога допустим);
- доступен через `ngrok.exe`/`ngrok` рядом с проектом или в `PATH`;
- свободна сессия для запуска HTTP-туннеля на порт 8000.

## Пошаговый сценарий
1. **Подготовка окружения**
   - Убедитесь, что в корне проекта доступен файл [`requirements.txt`](requirements.txt) с перечисленными зависимостями и установите их командой `pip install -r requirements.txt`.
   - Убедитесь, что Anki запущен, а расширение AnkiConnect активно.
   - Скопируйте `.env`-шаблон: `cp env.example .env` и впишите значение `NGROK_AUTHTOKEN=<ваш_токен>`.
     Файл `.env` должен лежать рядом с `main.py`: скрипт определяет абсолютный путь к собственной директории и всегда читает переменные окружения именно оттуда, поэтому можно запускать его из любого каталога.
  - При необходимости укажите `SEARCH_API_URL` и `SEARCH_API_KEY`: первая переменная задаёт конечную точку внешнего поиска (например, webhook в n8n), вторая — токен/ключ авторизации. Если поиск не нужен, оставьте их пустыми.
  - При необходимости переопределите `ANKI_URL` — базовый URL AnkiConnect. По умолчанию используется `http://127.0.0.1:8765`, что соответствует стандартным настройкам локального плагина.
   - Поместите `ngrok` рядом с проектом или добавьте в `PATH`.
2. **Запуск**
   - Выполните команду `python main.py`.
   - Скрипт стартует MCP-сервер (`fastmcp run server.py:app --transport http --host 127.0.0.1 --port 8000`) и поднимет ngrok-туннель. Токен берётся из переменной окружения `NGROK_AUTHTOKEN`, загруженной из `.env`.
3. **Ожидаемые сообщения**
   - В консоли появится блок вида:
     ```
     ✅ Всё поднято!
     • Локально:   http://127.0.0.1:8000/mcp
     • Публично:   https://....ngrok-free.app/mcp
     ```
     Эти строки выводятся после получения публичного URL от ngrok.
4. **Подключение коннектора**
   - Скопируйте опубликованный адрес `/mcp`, затем в интерфейсе ChatGPT откройте **Settings → Connectors → Add a connector → MCP Server** и вставьте его в поле URL.
   - Поля авторизации оставьте пустыми — она не требуется.
   - После добавления активируйте коннектор внутри конкретного чата, где планируете работать с Anki.
   - Оставьте окно запущенного скрипта открытым (терминал с `python main.py`); завершение `Ctrl+C` корректно остановит MCP и ngrok, а при закрытом терминале коннектор станет недоступен.

## Что умеет сервер
**Заметки**
- `anki.add_from_model` — автоматически подгоняет поля под выбранную модель, нормализует медиа и использует `dedup_key` для идемпотентных операций при массовом создании карточек. [Подробнее](docs/tools.md#ankiadd_from_model)
- `anki.add_notes` — добавляет заметки как есть, когда структуру полей контролирует клиент. [Подробнее](docs/tools.md#ankiadd_notes)
- `anki.find_notes` — возвращает идентификаторы заметок по запросу Anki с поддержкой пагинации. [Подробнее](docs/tools.md#ankifind_notes)
- `anki.note_info` — выдаёт подробные сведения о заметках (поля, теги, карточки) по их ID. [Подробнее](docs/tools.md#ankinote_info)
- `anki.update_notes` — обновляет существующие заметки, в том числе переносит их между колодами и добавляет медиа. [Подробнее](docs/tools.md#ankiupdate_notes)
- `anki.delete_notes` — удаляет выбранные заметки и сообщает статистику по выполненной операции. [Подробнее](docs/tools.md#ankidelete_notes)
- `anki.cards_info` — получает данные по карточкам, связанным с заметками (статус, колода, шаблон). [Подробнее](docs/tools.md#инструмент-anki-cards_info)
- `anki.cards_to_notes` — возвращает `noteId` для каждой переданной `cardId`, помогая связать карточки с заметками. [Подробнее](docs/tools.md#инструмент-anki-cards_to_notes)
- `anki.find_cards` — ищет карточки по запросу Anki, помогая уточнять связанные заметки и расписания. [Подробнее](docs/tools.md#инструмент-anki-find_cards)

**Колоды**
- `anki.list_decks` — перечисляет доступные колоды Anki. [Подробнее](docs/tools.md#ankilist_decks)
- `anki.create_deck` — создаёт новую колоду или возвращает уже существующую. [Подробнее](docs/tools.md#ankicreate_deck)
- `anki.rename_deck` — переименовывает колоду, если нужно изменить структуру дерева. [Подробнее](docs/tools.md#ankirename_deck)
- `anki.delete_decks` — удаляет колоды (с возможностью очистить дочерние). [Подробнее](docs/tools.md#ankidelete_decks)

**Модели**
- `anki.model_info` — выводит структуру модели: поля, шаблоны карточек и CSS. [Подробнее](docs/tools.md#ankimodel_info)
- `anki.list_models` — перечисляет доступные модели и помогает выбрать нужную структуру. [Подробнее](docs/tools.md#инструмент-anki-list_models)
- `anki.create_model` — создаёт пользовательскую модель с заданными полями и шаблонами. [Подробнее](docs/tools.md#ankicreate_model)
- `anki.update_model_templates` — обновляет HTML-шаблоны карточек в модели. [Подробнее](docs/tools.md#ankiupdate_model_templates)
- `anki.update_model_styling` — изменяет CSS модели, чтобы поддерживать оформление карточек. [Подробнее](docs/tools.md#ankiupdate_model_styling)

**Медиа**
- `anki.store_media` — сохраняет файлы в `collection.media`, возвращая результат AnkiConnect. [Подробнее](docs/tools.md#инструмент-anki-store_media)
- `anki.get_media` — скачивает содержимое медиафайла из коллекции. [Подробнее](docs/tools.md#ankiget_media)
- `anki.delete_media` — удаляет файлы из `collection.media`. [Подробнее](docs/tools.md#ankidelete_media)

**Сервисные вызовы**
- `anki.list_tags` — отдаёт все теги, используемые в базе. [Подробнее](docs/tools.md#инструмент-anki-list_tags)
- `anki.sync` — инициирует синхронизацию с AnkiWeb. [Подробнее](docs/tools.md#инструмент-anki-sync)
- `anki.invoke` — выполняет произвольный RPC AnkiConnect для редких сценариев. [Подробнее](docs/tools.md#anki.invoke)
- `greet` — быстрый «пинг» для проверки соединения. [Подробнее](docs/tools.md#greet)
- `search` — вызывает внешний поиск (например, webhook в n8n), возвращая результаты и курсор пагинации. [Подробнее](docs/tools.md#search)

Благодаря этим инструментам ChatGPT может получать структуру колод и моделей, управлять заметками вместе с вложениями, переиспользовать `dedup_key` для идемпотентных запросов и надёжно дополнять коллекцию Anki прямо из чата. Подробные параметры и примеры обращений описаны в [docs/tools.md](docs/tools.md).

## Модель Anki по умолчанию

По умолчанию сервер работает с пользовательской моделью `Поля для ChatGPT`. Чтобы запросы `anki.model_info` и `anki.add_from_model` корректно формировали заметки, важно сохранять порядок полей и шаблоны ровно в том виде, в котором они описаны ниже.

### Поля (порядок обязателен)
1. `Prompt` — исходный запрос или задача.
2. `Response` — ответ ChatGPT.
3. `Context` — дополнительная информация, которую следует помнить при повторении.
4. `Sources` — ссылки на материалы, выдержки из документов и другие источники.

### Шаблон «Front»
```html
<div class="prompt">{{Prompt}}</div>
{{#Context}}<div class="context">{{Context}}</div>{{/Context}}
{{tts de_DE voices=AwesomeTTS:Prompt}}
```

### Шаблон «Back»
```html
{{FrontSide}}
<hr id="answer">
<div class="response">{{Response}}</div>
{{#Sources}}<div class="sources">{{Sources}}</div>{{/Sources}}
```

### CSS модели
```css
.card {
  font-family: "Inter", "Segoe UI", sans-serif;
  font-size: 22px;
  text-align: left;
  line-height: 1.5;
}

.prompt {
  font-weight: 600;
  font-size: 24px;
  margin-bottom: 12px;
}

.context {
  color: #4a5568;
  font-style: italic;
  margin-bottom: 16px;
}

.response {
  color: #1a202c;
  font-size: 22px;
  margin-bottom: 12px;
}

.sources {
  color: #2d3748;
  font-size: 18px;
  white-space: pre-wrap;
}
```


TTS-вызов `{{tts de_DE voices=AwesomeTTS:Prompt}}` размещён на лицевой стороне и использует плагин AwesomeTTS с голосовым профилем, привязанным к полю `Prompt`. Убедитесь, что соответствующий профиль активирован в Anki, иначе воспроизведение произойдёт с настройками по умолчанию.

## Локальный smoke-тест
Запустите `python test_client.py`, чтобы проверить базовое взаимодействие с MCP-сервером без туннеля.
